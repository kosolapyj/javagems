#summary A brief introduction to Java Gems Logging library.

= Java Gems Logging = 

This is just another logging framework. It was invented, because its author needed to log one message with different facilities and with different severities for the each of these facilities. For example, the rudimentary requirement was to log "Too many connections" message as "security warning", "performance info" and "general notice". 

==  The First Touch ==

Basic features of Java Gems Logging library are following:

  * A logging  _facility_ is separated from a logging _severity_. (In fact, what about `java.util.logging.Level.CONFIG`? It is a _severity_, because it is _the_ level, but it seems to be much more like a facility for me.)
  * Each logging severity has a _meaning_ assigned (see javadoc API documentation). So, severities can be used uniformly across the application regardless of a number of developers or teams involved.
  * Each logging _record_ can have several logging facilities assigned and each of them may have a different severity. So, what is a _warning_ from security point of view can be also a _debug_ information from performance point of view.
  * Java Gems `Logger` is an _interface_. Providing different implementations with a different behavior, different demands of client application are supported.

=== Coding Example ===

At this moment, you should see [http://code.google.com/p/javagems/source/browse/trunk/docs/examples/srcs/logging/TheFirstTouch.java TheFirstTouch.java] example. 

The output of the example is as follows (except line numbers at the  beginnings of lines):

{{{
01: 2008-09-02 21:06:40.733 <main(1)> {{NOTICE}}	[logging.TheFirstTouch.main(67)]	'null'
02: 2008-09-02 21:06:40.850 <main(1)> {{NOTICE}}	[logging.TheFirstTouch.main(68)]	' Hello, world! '
03: 2008-09-02 21:06:40.852 <main(1)> {{NOTICE}}	[logging.TheFirstTouch.main(69)]	'logging.TheFirstTouch@cdedfd'
04: 2008-09-02 21:06:40.855 <main(1)> {{WARNING}}	[logging.TheFirstTouch.main(74)]	'Something is wrong.'
05: 2008-09-02 21:06:40.857 <main(1)> {{PERFORMANCE:NOTICE}}	[logging.TheFirstTouch.main(81)]	'Load is too high.'
06: 2008-09-02 21:06:40.858 <main(1)> {{SECURITY:NOTICE}}	[logging.TheFirstTouch.main(82)]	'Bad boys are here.'
07: 2008-09-02 21:06:40.860 <main(1)> {{PERFORMANCE:INFO}}	[logging.TheFirstTouch.main(87)]	'Performance information.'
08: 2008-09-02 21:06:40.862 <main(1)> {{PERFORMANCE:INFO}{SECURITY:WARNING}}	[logging.TheFirstTouch.main(94)]	'Too many connections.'
09: 2008-09-02 21:06:40.864 <main(1)> {{FATAL}}	[logging.TheFirstTouch.main(102)]	'java.lang.RuntimeException: Ooops.
10: 	at logging.TheFirstTouch.main(TheFirstTouch.java:102)
11: Caused by: java.lang.IllegalStateException: I'm the cause.
12: 	... 1 more
13: '
}}}

The basic structure of a logging record is the following:
  # At the beginning, there is a creation timestamp of the logging record.
  # In angle brackets, there is a thread identification. It is a thread name and its numeric ID. 
  # In braces, there are _logging tags_, i.e. pairs of logging facility and corresponding severity. If a logging record was created without any facility, so-called "null facility" with an empty name is used, see lines 1-3. A default severity is `NOTICE` and may be changed when an instance of `LoggingEntryPoint` is created.
  # In square brackets, there is a logging record creator identifications, i.e. a package, class, method and line where the logging record was created.
  # Finally, there is a logging message itself. Please note that the message is quoted, so you can easily catch whitespaces at the beginning and end of message, see line 2. 

The described format is a little bit verbose for simple usage. If this is a case, you can use `gems.logging.formatters.SimpleLoggingRecordFormatter` instead of `gems.logging.formatters.PlainLoggingRecordFormatter`, which is the default one. If you replace a line 
{{{
final LoggingHandler handler = new PrintStreamLoggingHandler(System.out);
}}}

with 

{{{
final LoggingHandler handler = new PrintStreamLoggingHandler(System.out, new SimpleLoggingRecordFormatter());
}}}

you will get an output similar to this:

{{{
2008-09-02 21:46:00 {NOTICE}	'null'
2008-09-02 21:46:00 {NOTICE}	' Hello, world! '
2008-09-02 21:46:00 {NOTICE}	'logging.TheFirstTouch@16cd7d5'
2008-09-02 21:46:00 {WARNING}	'Something is wrong.'
2008-09-02 21:46:00 {NOTICE}	'Load is too high.'
2008-09-02 21:46:00 {NOTICE}	'Bad boys are here.'
2008-09-02 21:46:00 {INFO}	'Performance information.'
2008-09-02 21:46:00 {WARNING}	'Too many connections.'
2008-09-02 21:46:00 {FATAL}	'java.lang.RuntimeException: Ooops.
	at logging.TheFirstTouch.main(TheFirstTouch.java:103)
Caused by: java.lang.IllegalStateException: I'm the cause.
	... 1 more
'
}}}

In this case, timestamps are formated with seconds precision, there are not any thread and creator information and only a maximal severity is reported instead of complete logging tags.

== Advanced Usage ==

=== Loggers ===

In the Java Gems Logging library, a logger is an interface. There are multiple implementations of this interface and a client may decide, which implementation is more suitable for it. Basically, a logger interface is simple, only two operations are possible: 

  # To add a logging handler to a logger. This is mostly done early during an application initialization, when logging subsystem is configured. By default, a logger has not any logging handlers. 
  # To pass a logging record to a logger. This is used for each logging message during the entire application run. Even if it is possible to pass a logging record directly to logger, this is usually done via _logging entry point_, which can more or less hide a complexity of logging record creation.

Additionally, there is a getter method for retriving a collection of logger's undrelaying handlers, but hopefully you will need to use it only when implementing own logger.

Following Logger interface implementations are provided:

  # *Synchronous logger*: A straightforward implementation of logger. It simply pass a given record to all underalying logging handlers. It operates in a thread of the caller, i.e. caller thread needs to wait until logging operation finishes.
  # *Asynchronous logger*: Logging, i.e. passing logging records to underlaying handlers is performed asynchronously by a background thread. Logging procedure invoked by the caller is designed to return as soon as possible, so a caller thread is not blocked by logging process even if very slow logging backends are used.

=== Handlers ===

_todo: complete this_

=== Filtering ===

_todo: complete this_